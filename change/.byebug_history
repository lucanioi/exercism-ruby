exit
best[subtarget] = [coin] + best_without
best_without
coin
subtarget
exit
best_without
best[subtarget]&.size &.<= best_without.size + 1
best_without = best[subtarget - coin]
next unless (best_without = best[subtarget - coin])
subtarget
best[subtarget]
best[0]
best
subtarget
coins.sort.reverse
coin
exit
best
target
(100..target).to_a[1]
(100..target)[1]
(100..target).first
100..target.first
coins.sort.reverse
cons
best[target]
target
exit
current_coin
back_track! until !last || current_coin == last
current_coin
last
exit
last
exit
change
last
while (last = change.pop) == current_coin do end
while (last = change.pop) == current_coin; do; end
while (last = change.pop) == current_coin; end
while last = change.pop == current_coin; end
exit
 change.pop == current_coin
exit
current_coin
 back_track(change.dup)
 register_change(change)
change
exit
exi
(0...change_with_min_coins&.size).include? change.size
(0...change_with_min_coins&.size)
change_with_min_coins
register_change(change)
change_with_min_coins
exit
change
exit
change
changes
exit
back_track! until !change.last || current_coin == change.last
change.pop while change.last == current_coin
back_track! until !current_coin || current_coin == change.last
change
current_coin
change.pop while change.last == current_coin
current_coin
change.last
back_track(change)
changes
total
